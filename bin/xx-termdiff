#!/usr/bin/env python
"""File comparison and merge tool.

This is a single file, curses-based version of xxdiff in Python. I, the author
of xxdiff, am now working almost exclusively on remote machines using tmux,
bash, emacs, and I need my nice file comparison and merge tool to work in a
console-only environment. Nothing decent was available as of 2013-05-04, so I
decided to rewrite xxdiff in curses.

  Note: I will eventually rewrite this in Emacs-LISP, as a better version of ediff
  (which is unfortunately insufficient, even with efforts configuring it), but
  dumping Emacs is not functional anymore (it dumps core on Linux), so startup
  time will probably be an issue, so there is still value in having a visual
  diff renderer / simple merge without editing available like this.

"""
__author__ = 'Martin Blais <blais@furius.ca>'
__copyright__ = 'GNU GPL v3'

import sys, os, re
import curses
from subprocess import Popen, PIPE


# Kinds of changes                     [2-way] [3-way]
LINE_SAME        = 'LINE_SAME       ' # (AA)    (AAA)
LINE_DIFF_1      = 'LINE_DIFF_1     ' #         (BAA)
LINE_DIFF_2      = 'LINE_DIFF_2     ' #         (ABA)
LINE_DIFF_3      = 'LINE_DIFF_3     ' #         (AAB)
LINE_DELETE_1    = 'LINE_DELETE_1   ' #         (-AA)
LINE_DELETE_2    = 'LINE_DELETE_2   ' #         (A-A)
LINE_DELETE_3    = 'LINE_DELETE_3   ' #         (AA-)
LINE_INSERT_1    = 'LINE_INSERT_1   ' # (A-)    (A--)
LINE_INSERT_2    = 'LINE_INSERT_2   ' # (-A)    (-A-)
LINE_INSERT_3    = 'LINE_INSERT_3   ' #         (--A)
LINE_DIFF_ALL    = 'LINE_DIFF_ALL   ' # (AB)    (ABC)
LINE_DIFFDEL_1   = 'LINE_DIFFDEL_1  ' #         (-AB)
LINE_DIFFDEL_2   = 'LINE_DIFFDEL_2  ' #         (A-B)
LINE_DIFFDEL_3   = 'LINE_DIFFDEL_3  ' #         (AB-)
LINE_DIRECTORIES = 'LINE_DIRECTORIES' #

# Type of selection of each line.
SEL_SEL1       = object()
SEL_SEL2       = object()
SEL_SEL3       = object()
SEL_UNSELECTED = object()
SEL_NEITHER    = object()


# Left, Middle, Right
L, R, M = 0, 1, 2


class Hunk(object):
  """A diff hunk, including regions which are the same."""
  def __init__(self, hunk_type):
    self.hunk_type = hunk_type
    # Begin and end line numbers for each file.
    self.linesL = None
    self.linesR = None
    self.linesM = None

  def __str__(self):
    return 'Hunk({}, {}, {}, {})'.format(self.hunk_type,
                                         self.linesL, self.linesM, self.linesR)


class Matcher(object):
  """A convenience class that store the result of the last match operation.
  This is used to create cascading elif conditions on regexps."""
  def __call__(self, *args, **kw):
    self.mo = re.match(*args, **kw)
    return self.mo


def line_pair((line1, line2)):
  line1 = int(line1)
  if line2 is None:
    line2 = line1
  else:
    line2 = int(line2) + 1
  return (line1, line2)

def parse_diff2_line(line):
  """Parse a single line of diff's output. This is standardized, to some extent,
  and there are many kinds of diff tools that will output compatible lists of
  changes."""

  line_type = None
  hunk = None
  matcher = Matcher()

  c = line[0]
  if c in '<>-':
    pass

  elif matcher(r'(\d+)(?:,(\d+))?c(\d+)(?:,(\d+))?', line):
    f1n1, f1n2 = line_pair(matcher.mo.group(1,2))
    f2n1, f2n2 = line_pair(matcher.mo.group(3,4))
    line_type = LINE_DIFF_ALL

  elif matcher(r'(\d+)(?:,(\d+))?d(\d+)', line):
    f1n1, f1n2 = line_pair(matcher.mo.group(1,2))
    f2n1 = f2n2 = int(matcher.mo.group(3)) + 1
    line_type = LINE_INSERT_1

  elif matcher(r'(\d+)a(\d+)(?:,(\d+))?', line):
    f1n1 = f1n2 = int(matcher.mo.group(1)) + 1
    f2n1, f2n2 = line_pair(matcher.mo.group(2,3))
    line_type = LINE_INSERT_2

  elif matcher(r'\ No newline at end of file', line):
    f1n1 = f1n2 = f2n1 = f2n2 = None
    line_type = LINE_DIRECTORIES

  if line_type is not None:
    hunk = Hunk(line_type)
    hunk.linesL = (f1n1, f1n2)
    hunk.linesR = (f2n1, f2n2)

  return hunk


def parse_diff2(program, filename1, filename2):
  """Parse a two-way diff."""
  p = Popen((program, filename1, filename2), stdout=PIPE, stderr=PIPE)
  out, err = p.communicate()
  hunks = []
  for line in out.splitlines():
    hunk = parse_diff2_line(line)
    if hunk is not None:
      hunks.append(hunk)
  return hunks


def parse_diff3(program, filename1, filename2, filename3):
  """Parse a single line of diff3's output. 'f' is a file object."""
  p = Popen((program, filename1, filename2, filename3), stdout=PIPE, stderr=PIPE)
  out, err = p.communicate()

  matcher = Matcher()
  hunks = []

  FILE_MAP = {'1': L, '2': M, '3': R}

  head_line, lines = None, {}
  for line in out.splitlines():
    if matcher('====(\d+)?', line):
      hline = matcher.mo.group(1)
      head_line = int(hline) if hline else None

    elif matcher('([123]):(\d+)(?:,(\d+))?([ac])', line):
      fileno = FILE_MAP[matcher.mo.group(1)]
      assert fileno not in lines

      beg = int(matcher.mo.group(2))
      if matcher.mo.group(4) == 'a':
        beg += 1

      end = (int(matcher.mo.group(3)) + 1) if matcher.mo.group(3) else beg

      lines[fileno] = (beg, end, matcher.mo.group(4))

      if len(lines) == 3:
        signature = (head_line, lines[L][2], lines[M][2], lines[R][2])
        line_type = DIFF3_MAP[signature]
        hunk = Hunk(line_type)
        hunk.linesL = lines[L][:2]
        hunk.linesM = lines[M][:2]
        hunk.linesR = lines[R][:2]
        hunks.append(hunk)
        head_line, lines = None, {}

  return hunks


DIFF3_MAP = {
  (1, 'c', 'c', 'c')    : LINE_DIFF_1,
  (2, 'c', 'c', 'c')    : LINE_DIFF_2,
  (3, 'c', 'c', 'c')    : LINE_DIFF_3,
  (1, 'a', 'c', 'c')    : LINE_DELETE_1,
  (2, 'c', 'a', 'c')    : LINE_DELETE_2,
  (3, 'c', 'c', 'a')    : LINE_DELETE_3,
  (1, 'c', 'a', 'a')    : LINE_INSERT_1,
  (2, 'a', 'c', 'a')    : LINE_INSERT_2,
  (3, 'a', 'a', 'c')    : LINE_INSERT_3,
  (None, 'c', 'c', 'c') : LINE_DIFF_ALL,
  (None, 'a', 'c', 'c') : LINE_DIFFDEL_1,
  (None, 'c', 'a', 'c') : LINE_DIFFDEL_2,
  (None, 'c', 'c', 'a') : LINE_DIFFDEL_3,
}


class FileWithNo(object):
  "A file object wrapper that tracks its line number, 1-based."
  def __init__(self, f):
    self.lineno = 1
    self.f = f

  def readline(self):
    self.lineno += 1
    return self.f.readline()


EMPTY_LINE = 'X' * 80
SEPARATOR = '|'


def render_line(f, line, color, width):
  """Render a single file's line in the given terminal color, fitting exactly in
  the specifed width."""
  f.write(curses.tparm(curses.tigetstr('setaf'), 0))
  f.write(color)
  f.write('{:{w}.{w}}'.format(line.rstrip('\n\r'), w=width))
  f.write(COLOR_BASE)
  f.write(curses.tparm(curses.tigetstr('setaf'), 7))

COLORS = [
    ('COLOR_BASE',                  0),
    ('COLOR_SAME',                  250),
    ('COLOR_SAME_OTHER',              153),
    #('COLOR_SAME_TWO_HIGHLIGHT',          110),
    ('COLOR_INSERT',                157),
    ('COLOR_DELETE',                153),
    ('COLOR_CHANGE',              223),
    #('COLOR_CHANGE_HIGHLIGHT',          187),
    ('COLOR_BLANK',              247),

    # ('COLOR_SAME_BLANK',            249),
    # ('COLOR_DELETE_BLANK',          247),
    # ('COLOR_INSERT_BLANK',          247),
    # ('COLOR_SELECTED',              182),
    # ('COLOR_SELECTED_HIGHLIGHT',          182),
    # ('COLOR_IGNORE_DISPLAY',        253),
    # ('COLOR_IGNORE_DISPLAY_HIGHLIGHT',    252),
    # ('COLOR_IGNORE_DISPLAY_ONLY',   252),
    # ('COLOR_IGNORE_DISPLAY_NONLY',  252),
    # ('COLOR_DELETED',               102),
    # ('COLOR_DELETED_HIGHLIGHT',           66),
    # ('COLOR_IGNORED',               249),
    # ('COLOR_DIRECTORIES',           80),
    # ('COLOR_MERGED_UNDECIDED',      187),
    # ('COLOR_MERGED_DECIDED_1',      246),
    # ('COLOR_MERGED_DECIDED_1_HIGHLIGHT',  249),
    # ('COLOR_MERGED_DECIDED_2',      246),
    # ('COLOR_MERGED_DECIDED_2_HIGHLIGHT',  249),
    # ('COLOR_MERGED_DECIDED_3',      246),
    # ('COLOR_MERGED_DECIDED_3_HIGHLIGHT',  249),
    # ('COLOR_MERGED_DECIDED_NEITHER', 249),
    ]
def init_colors():
  for color_name, color_id in COLORS:
    globals()[color_name] = curses.tparm(curses.tigetstr('setab'), color_id)

  global HUNK_COLORS_2
  HUNK_COLORS_2 = {
    LINE_SAME        : (COLOR_SAME   , COLOR_SAME)   ,
    LINE_DIFF_ALL    : (COLOR_CHANGE , COLOR_CHANGE) ,
    LINE_INSERT_1    : (COLOR_INSERT , COLOR_BLANK)  ,
    LINE_INSERT_2    : (COLOR_BLANK  , COLOR_DELETE) ,
    }

  global HUNK_COLORS_3
  HUNK_COLORS_3 = {
    LINE_SAME        : (COLOR_SAME       , COLOR_SAME       , COLOR_SAME)       ,
    LINE_DIFF_1      : (COLOR_CHANGE     , COLOR_SAME_OTHER , COLOR_SAME_OTHER) ,
    LINE_DIFF_2      : (COLOR_SAME_OTHER , COLOR_CHANGE     , COLOR_SAME_OTHER) ,
    LINE_DIFF_3      : (COLOR_SAME_OTHER , COLOR_SAME_OTHER , COLOR_CHANGE)     ,
    LINE_DELETE_1    : (COLOR_BLANK      , COLOR_SAME_OTHER , COLOR_SAME_OTHER) ,
    LINE_DELETE_2    : (COLOR_SAME_OTHER , COLOR_BLANK      , COLOR_SAME_OTHER) ,
    LINE_DELETE_3    : (COLOR_SAME_OTHER , COLOR_SAME_OTHER , COLOR_BLANK)     ,
    LINE_INSERT_1    : (COLOR_INSERT     , COLOR_BLANK      , COLOR_BLANK)      ,
    LINE_INSERT_2    : (COLOR_BLANK      , COLOR_INSERT     , COLOR_BLANK)      ,
    LINE_INSERT_3    : (COLOR_BLANK      , COLOR_BLANK      , COLOR_INSERT)     ,
    LINE_DIFF_ALL    : (COLOR_CHANGE     , COLOR_CHANGE     , COLOR_CHANGE)     ,
    LINE_DIFFDEL_1   : (COLOR_BLANK      , COLOR_CHANGE     , COLOR_CHANGE)     ,
    LINE_DIFFDEL_2   : (COLOR_CHANGE     , COLOR_BLANK      , COLOR_CHANGE)     ,
    LINE_DIFFDEL_3   : (COLOR_CHANGE     , COLOR_CHANGE     , COLOR_BLANK)      ,
    }


def main():
  import argparse, logging
  logging.basicConfig(level=logging.INFO, format='%(levelname)-8s: %(message)s')
  parser = argparse.ArgumentParser(__doc__.strip())

  parser.add_argument('filenames', nargs='+',
                      help='Filenames')

  parser.add_argument('--prog-diff2', '--prog-diff', action='store', default='diff',
                      help="Executable to call for two-day diffs.")
  parser.add_argument('--prog-diff3', action='store', default='diff3',
                      help="Executable to call for three-day diffs.")

  opts = parser.parse_args()

  nfiles = len(opts.filenames)
  if nfiles == 2:
    hunks = parse_diff2(opts.prog_diff2, *opts.filenames)
    filenames = {L: opts.filenames[0],
                 R: opts.filenames[1]}
  elif nfiles == 3:
    hunks = parse_diff3(opts.prog_diff3, *opts.filenames)
    filenames = {L: opts.filenames[0],
                 M: opts.filenames[1],
                 R: opts.filenames[2]}
  else:
    parser.error("Invalid number of files: should be 2 or 3")

  # FIXME: Auto-compute using curses
  width = 60

  outf = sys.stdout

  files = dict((k, FileWithNo(open(v))) for (k, v) in filenames.iteritems())
  for hunk in hunks:
    ##print '********************', hunk

    # Check sizes
    sizeL = hunk.linesL[0] - files[L].lineno
    sizeR = hunk.linesR[0] - files[R].lineno
    assert sizeL == sizeR, (sizeL, sizeR)
    if nfiles == 3:
      sizeM = hunk.linesM[0] - files[M].lineno
      assert sizeM == sizeL, (sizeM, sizeL)

    # Render same lines.
    while files[L].lineno < hunk.linesL[0]:
      lineL = files[L].readline()
      lineR = files[R].readline()

      if nfiles == 2:
        colL, colR = HUNK_COLORS_2[LINE_SAME]
        render_line(outf, lineL, colL, width)
        outf.write(SEPARATOR)
        render_line(outf, lineR, colR, width)
      else:
        lineM = files[M].readline()
        colL, colM, colR = HUNK_COLORS_3[LINE_SAME]
        render_line(outf, lineL, colL, width)
        outf.write(SEPARATOR)
        render_line(outf, lineM, colM, width)
        outf.write(SEPARATOR)
        render_line(outf, lineR, colR, width)

      sys.stdout.write('\n')

    # Render diff hunk.
    while 1:
      didread = False
      lineL = lineR = lineM = EMPTY_LINE
      if files[L].lineno < hunk.linesL[1]:
        lineL = files[L].readline()
        didread = True

      if files[R].lineno < hunk.linesR[1]:
        lineR = files[R].readline()
        didread = True

      if nfiles == 3 and files[M].lineno < hunk.linesM[1]:
        lineM = files[M].readline()
        didread = True

      if not didread:
        break

      if nfiles == 2:
        colL, colR = HUNK_COLORS_2[hunk.hunk_type]
        render_line(outf, lineL, colL, width)
        outf.write(SEPARATOR)
        render_line(outf, lineR, colR, width)
      else:
        colL, colM, colR = HUNK_COLORS_3[hunk.hunk_type]
        render_line(outf, lineL, colL, width)
        outf.write(SEPARATOR)
        render_line(outf, lineM, colM, width)
        outf.write(SEPARATOR)
        render_line(outf, lineR, colR, width)

      sys.stdout.write('\n')

  # FIXME: render the final same lines as well



  # FIMXE: Find an example version of more or less in curses, integrate this.

  # FIXME: Find in vimdiff:
  # - Can I overrride the colors?
  # - Is there a way to skip between hunks?
  # - Can I copy hunks from side to side?
  # - How do I open a fold? (see foldmethod)

  # FIXME: Dump an Emacs with just ediff in site.el, is it fast to start?








def find_colors():
  "One-off funciton used to compute the terminal colors corresponding to xxdiff's."
  colors = [
      ( 'COLOR_SAME                 ' , "#bebebe", "#000000" ),
      ( 'COLOR_SAME_BLANK           ' , "#b3b3b3", "#000000" ),
      ( 'COLOR_DIFF_ONE             ' , "#eee8aa", "#000000" ),
      ( 'COLOR_DIFF_ONE_SUP         ' , "#cdc9a5", "#000000" ),
      ( 'COLOR_DIFF_TWO             ' , "#b2dfee", "#000000" ),
      ( 'COLOR_DIFF_TWO_SUP         ' , "#9ac0cd", "#000000" ),
      ( 'COLOR_DELETE               ' , "#b2dfee", "#000000" ),
      ( 'COLOR_DELETE_BLANK         ' , "#a3a3a3", "#000000" ),
      ( 'COLOR_INSERT               ' , "#b4eeb4", "#000000" ),
      ( 'COLOR_INSERT_BLANK         ' , "#a3a3a3", "#000000" ),
      ( 'COLOR_SELECTED             ' , "#dda0dd", "#000000" ),
      ( 'COLOR_SELECTED_SUP         ' , "#d8bfd8", "#000000" ),
      ( 'COLOR_IGNORE_DISPLAY       ' , "#d9d9d9", "#000000" ),
      ( 'COLOR_IGNORE_DISPLAY_SUP   ' , "#cccccc", "#000000" ),
      ( 'COLOR_IGNORE_DISPLAY_ONLY  ' , "#cccccc", "#000000" ),
      ( 'COLOR_IGNORE_DISPLAY_NONLY ' , "#cccccc", "#000000" ),
      ( 'COLOR_DELETED              ' , "#778899", "#000000" ),
      ( 'COLOR_DELETED_SUP          ' , "#708090", "#000000" ),
      ( 'COLOR_IGNORED              ' , "#b3b3b3", "#4d4d4d" ),
      ( 'COLOR_DIRECTORIES          ' , "#48d1cc", "#000000" ),
      ( 'COLOR_MERGED_UNDECIDED     ' , "#cdc9a5", "#000000" ),
      ( 'COLOR_MERGED_DECIDED_1     ' , "#999999", "#000000" ),
      ( 'COLOR_MERGED_DECIDED_1_SUP ' , "#b3b3b3", "#000000" ),
      ( 'COLOR_MERGED_DECIDED_2     ' , "#999999", "#000000" ),
      ( 'COLOR_MERGED_DECIDED_2_SUP ' , "#b3b3b3", "#000000" ),
      ( 'COLOR_MERGED_DECIDED_3     ' , "#999999", "#000000" ),
      ( 'COLOR_MERGED_DECIDED_3_SUP ' , "#b3b3b3", "#000000" ),
      ( 'COLOR_MERGED_DECIDED_NEITHER' , "#b3b3b3", "#000000" ),
      ]
  import mapcolors
  for color_name, color_bg, color_fg in colors:
    (rgb, color_id, distance) = mapcolors.find_closest_color(mapcolors.getrgb(color_bg))
    print curses.tparm(curses.tigetstr('setab'), color_id),
    (rgb, color_id, distance) = mapcolors.find_closest_color(mapcolors.getrgb(color_fg))
    print curses.tparm(curses.tigetstr('setaf'), color_id),
    print color_name
  print curses.tparm(curses.tigetstr('setab'), 0)
  print curses.tparm(curses.tigetstr('setaf'), 7)

  for color_name, color_bg, color_fg in colors:
    (rgb, color_id, distance) = mapcolors.find_closest_color(mapcolors.getrgb(color_bg))
    print color_name, color_id



if __name__ == '__main__':
  curses.setupterm()
  print curses.getmaxyx()
  init_colors()
  #find_colors()
  main()
