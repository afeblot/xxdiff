#!/usr/bin/env python
"""File comparison and merge tool.

This is a single file, curses-based version of xxdiff in Python. I, the author
of xxdiff, am now working almost exclusively on remote machines using tmux,
bash, emacs, and I need my nice file comparison and merge tool to work in a
console-only environment. Nothing decent was available as of 2013-05-04, so I
decided to rewrite xxdiff in curses.

  Note: I will eventually rewrite this in Emacs-LISP, as a better version of ediff
  (which is unfortunately insufficient, even with efforts configuring it), but
  dumping Emacs is not functional anymore (it dumps core on Linux), so startup
  time will probably be an issue, so there is still value in having a visual
  diff renderer / simple merge without editing available like this.

"""
__author__ = 'Martin Blais <blais@furius.ca>'
__copyright__ = 'GNU GPL v3'

import sys, os, re
import curses
from subprocess import Popen, PIPE


# Kinds of changes                     [2-way] [3-way]
LINE_SAME        = 'LINE_SAME       ' # (AA)    (AAA)
LINE_DIFF_1      = 'LINE_DIFF_1     ' #         (BAA)
LINE_DIFF_2      = 'LINE_DIFF_2     ' #         (ABA)
LINE_DIFF_3      = 'LINE_DIFF_3     ' #         (AAB)
LINE_DELETE_1    = 'LINE_DELETE_1   ' #         (-AA)
LINE_DELETE_2    = 'LINE_DELETE_2   ' #         (A-A)
LINE_DELETE_3    = 'LINE_DELETE_3   ' #         (AA-)
LINE_INSERT_1    = 'LINE_INSERT_1   ' # (A-)    (A--)
LINE_INSERT_2    = 'LINE_INSERT_2   ' # (-A)    (-A-)
LINE_INSERT_3    = 'LINE_INSERT_3   ' #         (--A)
LINE_DIFF_ALL    = 'LINE_DIFF_ALL   ' # (AB)    (ABC)
LINE_DIFFDEL_1   = 'LINE_DIFFDEL_1  ' #         (-AB)
LINE_DIFFDEL_2   = 'LINE_DIFFDEL_2  ' #         (A-B)
LINE_DIFFDEL_3   = 'LINE_DIFFDEL_3  ' #         (AB-)
LINE_DIRECTORIES = 'LINE_DIRECTORIES' #

# Type of selection of each line.
SEL_SEL1       = object()
SEL_SEL2       = object()
SEL_SEL3       = object()
SEL_UNSELECTED = object()
SEL_NEITHER    = object()


# Left, Middle, Right
L, R, M = 0, 1, 2


class Hunk(object):
  """A diff hunk, including regions which are the same."""
  def __init__(self, hunk_type):
    self.hunk_type = hunk_type
    # Begin and end line numbers for each file.
    self.linesL = None
    self.linesR = None
    self.linesM = None

  def __str__(self):
    return 'Hunk({}, {}, {}, {})'.format(self.hunk_type,
                                         self.linesL, self.linesM, self.linesR)


class Matcher(object):
  """A convenience class that store the result of the last match operation.
  This is used to create cascading elif conditions on regexps."""
  def __call__(self, *args, **kw):
    self.mo = re.match(*args, **kw)
    return self.mo


def line_pair((line1, line2)):
  line1 = int(line1)
  if line2 is None:
    line2 = line1 + 1
  else:
    line2 = int(line2) + 1
  return (line1, line2)

def parse_diff2_line(line):
  """Parse a single line of diff's output. This is standardized, to some extent,
  and there are many kinds of diff tools that will output compatible lists of
  changes."""

  line_type = None
  hunk = None
  matcher = Matcher()

  c = line[0]
  if c in '<>-':
    pass

  elif matcher(r'(\d+)(?:,(\d+))?c(\d+)(?:,(\d+))?', line):
    f1n1, f1n2 = line_pair(matcher.mo.group(1,2))
    f2n1, f2n2 = line_pair(matcher.mo.group(3,4))
    line_type = LINE_DIFF_ALL

  elif matcher(r'(\d+)(?:,(\d+))?d(\d+)', line):
    f1n1, f1n2 = line_pair(matcher.mo.group(1,2))
    f2n1 = f2n2 = int(matcher.mo.group(3)) + 1
    line_type = LINE_INSERT_1

  elif matcher(r'(\d+)a(\d+)(?:,(\d+))?', line):
    f1n1 = f1n2 = int(matcher.mo.group(1)) + 1
    f2n1, f2n2 = line_pair(matcher.mo.group(2,3))
    line_type = LINE_INSERT_2

  elif matcher(r'\ No newline at end of file', line):
    f1n1 = f1n2 = f2n1 = f2n2 = None
    line_type = LINE_DIRECTORIES

  if line_type is not None:
    hunk = Hunk(line_type)
    hunk.linesL = (f1n1, f1n2)
    hunk.linesR = (f2n1, f2n2)

  return hunk


def parse_diff2(program, filename1, filename2):
  """Parse a two-way diff."""
  p = Popen((program, filename1, filename2), stdout=PIPE, stderr=PIPE)
  out, err = p.communicate()
  hunks = []
  for line in out.splitlines():
    hunk = parse_diff2_line(line)
    if hunk is not None:
      hunks.append(hunk)
  return hunks


def parse_diff3(program, filename1, filename2, filename3):
  """Parse a single line of diff3's output. 'f' is a file object."""
  p = Popen((program, filename1, filename2, filename3), stdout=PIPE, stderr=PIPE)
  out, err = p.communicate()

  matcher = Matcher()
  hunks = []

  FILE_MAP = {'1': L, '2': M, '3': R}

  head_line, lines = None, {}
  for line in out.splitlines():
    if matcher('====(\d+)?', line):
      hline = matcher.mo.group(1)
      head_line = int(hline) if hline else None

    elif matcher('([123]):(\d+)(?:,(\d+))?([ac])', line):
      fileno = FILE_MAP[matcher.mo.group(1)]
      assert fileno not in lines

      beg = int(matcher.mo.group(2))
      if matcher.mo.group(4) == 'a':
        beg += 1

      end = (int(matcher.mo.group(3)) + 1) if matcher.mo.group(3) else beg

      lines[fileno] = (beg, end, matcher.mo.group(4))

      if len(lines) == 3:
        signature = (head_line, lines[L][2], lines[M][2], lines[R][2])
        line_type = DIFF3_MAP[signature]
        hunk = Hunk(line_type)
        hunk.linesL = lines[L][:2]
        hunk.linesM = lines[M][:2]
        hunk.linesR = lines[R][:2]
        hunks.append(hunk)
        head_line, lines = None, {}

  return hunks


DIFF3_MAP = {
  (1, 'c', 'c', 'c')    : LINE_DIFF_1,
  (2, 'c', 'c', 'c')    : LINE_DIFF_2,
  (3, 'c', 'c', 'c')    : LINE_DIFF_3,
  (1, 'a', 'c', 'c')    : LINE_DELETE_1,
  (2, 'c', 'a', 'c')    : LINE_DELETE_2,
  (3, 'c', 'c', 'a')    : LINE_DELETE_3,
  (1, 'c', 'a', 'a')    : LINE_INSERT_1,
  (2, 'a', 'c', 'a')    : LINE_INSERT_2,
  (3, 'a', 'a', 'c')    : LINE_INSERT_3,
  (None, 'c', 'c', 'c') : LINE_DIFF_ALL,
  (None, 'a', 'c', 'c') : LINE_DIFFDEL_1,
  (None, 'c', 'a', 'c') : LINE_DIFFDEL_2,
  (None, 'c', 'c', 'a') : LINE_DIFFDEL_3,
}


class FileWithNo(object):
  "A file object wrapper that tracks its line number, 1-based."

  def __init__(self, f):
    self.lineno = 1
    self.f = f

  def __str__(self):
    return 'FileWithNo({}, lineno={})'.format(self.f.name, self.lineno)
  __repr__ = __str__

  def readline(self):
    self.lineno += 1
    return self.f.readline()


SEPARATOR = '|'


class TruncLineWriter(object):
  "Writes to a file up to the given number of characters."

  def __init__(self, f, width):
    self.f = f
    self.width = width
    self.c = 0

  def write_text(self, text):
    remaining = self.width - self.c
    if remaining <= 0:
      return
    if len(text) < remaining:
      self.f.write(text)
      self.c += len(text)
    else:
      self.f.write(text[:remaining])
      self.c = self.width

  def complete(self):
    "Pad the end of the line with blanks, up to width, if necessary."
    remaining = self.width - self.c
    if remaining > 0:
      self.f.write(' ' * remaining)


def render_line(f, line, color, width, hd=None):
  """Render a single file's line in the given terminal color, fitting exactly in
  the specifed width."""
  if line is None:
    line = EMPTY_LINE
    color = COLOR_BLANK

  line = line.rstrip('\n\r')
  wr = TruncLineWriter(f, width)
  f.write(color)
  if hd is None:
    wr.write_text(line)
  else:
    ipre, isfx = hd
    wr.write_text(line[:ipre])
    f.write(COLOR_HIGHLIGHT[color])
    wr.write_text(line[ipre:isfx])
    f.write(color)
    wr.write_text(line[isfx:])
  wr.complete()

  f.write(COLOR_BASE)


COLORS = [
    ('COLOR_BASE'                 ,   0, 7),
    ('COLOR_SAME'                 , 250, 0),
    ('COLOR_SAME_OTHER'           , 153, 0),
    ('COLOR_SAME_OTHER_HIGHLIGHT' , 110, 0),
    ('COLOR_INSERT'               , 157, 0),
    ('COLOR_DELETE'               , 157, 0),
    ('COLOR_CHANGE'               , 223, 0),
    ('COLOR_CHANGE_HIGHLIGHT'     , 229, 0),
    ('COLOR_BLANK'                , 246, 0),
    ('COLOR_TITLE'                , 19 , 15),
    ]


def init_colors():
  for color_name, color_id_bg, color_id_fg in COLORS:
    globals()[color_name] = (curses.tparm(curses.tigetstr('setab'), color_id_bg) +
                             curses.tparm(curses.tigetstr('setaf'), color_id_fg))


  global HUNK_COLORS_2
  HUNK_COLORS_2 = {
    LINE_SAME        : (COLOR_SAME   , COLOR_SAME)   ,
    LINE_DIFF_ALL    : (COLOR_CHANGE , COLOR_CHANGE) ,
    LINE_INSERT_1    : (COLOR_INSERT , COLOR_BLANK)  ,
    LINE_INSERT_2    : (COLOR_BLANK  , COLOR_DELETE) ,
    }

  global HUNK_COLORS_3
  HUNK_COLORS_3 = {
    LINE_SAME        : (COLOR_SAME       , COLOR_SAME       , COLOR_SAME)       ,
    LINE_DIFF_1      : (COLOR_CHANGE     , COLOR_SAME_OTHER , COLOR_SAME_OTHER) ,
    LINE_DIFF_2      : (COLOR_SAME_OTHER , COLOR_CHANGE     , COLOR_SAME_OTHER) ,
    LINE_DIFF_3      : (COLOR_SAME_OTHER , COLOR_SAME_OTHER , COLOR_CHANGE)     ,
    LINE_DELETE_1    : (COLOR_BLANK      , COLOR_SAME_OTHER , COLOR_SAME_OTHER) ,
    LINE_DELETE_2    : (COLOR_SAME_OTHER , COLOR_BLANK      , COLOR_SAME_OTHER) ,
    LINE_DELETE_3    : (COLOR_SAME_OTHER , COLOR_SAME_OTHER , COLOR_BLANK)      ,
    LINE_INSERT_1    : (COLOR_INSERT     , COLOR_BLANK      , COLOR_BLANK)      ,
    LINE_INSERT_2    : (COLOR_BLANK      , COLOR_INSERT     , COLOR_BLANK)      ,
    LINE_INSERT_3    : (COLOR_BLANK      , COLOR_BLANK      , COLOR_INSERT)     ,
    LINE_DIFF_ALL    : (COLOR_CHANGE     , COLOR_CHANGE     , COLOR_CHANGE)     ,
    LINE_DIFFDEL_1   : (COLOR_BLANK      , COLOR_CHANGE     , COLOR_CHANGE)     ,
    LINE_DIFFDEL_2   : (COLOR_CHANGE     , COLOR_BLANK      , COLOR_CHANGE)     ,
    LINE_DIFFDEL_3   : (COLOR_CHANGE     , COLOR_CHANGE     , COLOR_BLANK)      ,
    }

  global COLOR_HIGHLIGHT
  COLOR_HIGHLIGHT = {
      COLOR_SAME_OTHER: COLOR_SAME_OTHER_HIGHLIGHT,
      COLOR_CHANGE:  COLOR_CHANGE_HIGHLIGHT,
      }


def render_same_region(files):
  """Given a mapping of files, render a same-region, that is, a region between
  hunks whose text should match."""


def compute_horizontal_prefix(lines):
  """Return the first character that differs between the given lines."""
  for i in xrange(min(map(len, lines))):
    c = lines[0][i]
    for oline in lines[1:]:
      if oline[i] != c:
        return i

def compute_horizontal_suffix(lines):
  """Return the last character from the back that differs between the given
  lines."""
  for i in xrange(min(map(len, lines))):
    c = lines[0][-i]
    for oline in lines[1:]:
      if oline[-i] != c:
        return i
  return 0

def compute_horizontal_diffs(lines):
  """Compute the horizontal diffs of the lines that have content.
  'lines' is a dict of side (L, R, M) to lines. Lines without
  content have indexes returned as None."""

  # Linearize order or items.
  items = lines.items()

  # The result, initialized.
  indices = dict((side, None) for side in lines.iterkeys())

  # Operate on the valid lines only.
  valid_lines = [line for (side, line) in items if line]
  if len(valid_lines) < 2:
    return indices

  # Compute prefix and suffix (this is a simpler algorithm than xxdiff).
  ipre = compute_horizontal_prefix(valid_lines)
  isfx = compute_horizontal_suffix(valid_lines)

  # Fill in the computed results.
  for (side, line) in items:
    if line:
      indices[side] = (ipre, max(ipre, len(line)-isfx))
  return indices


def main():
  import argparse, logging
  logging.basicConfig(level=logging.INFO, format='%(levelname)-8s: %(message)s')
  parser = argparse.ArgumentParser(__doc__.strip())

  parser.add_argument('filenames', nargs='+',
                      help='Filenames')

  parser.add_argument('--prog-diff2', '--prog-diff', action='store', default='diff',
                      help="Executable to call for two-day diffs.")
  parser.add_argument('--prog-diff3', action='store', default='diff3',
                      help="Executable to call for three-day diffs.")

  parser.add_argument('--blank-char', action='store', default=' ',
                      help="Blank character to use for filler.")

  opts = parser.parse_args()

  nfiles = len(opts.filenames)
  if nfiles == 2:
    hunks = parse_diff2(opts.prog_diff2, *opts.filenames)
    filenames = {L: opts.filenames[0],
                 R: opts.filenames[1]}
  elif nfiles == 3:
    hunks = parse_diff3(opts.prog_diff3, *opts.filenames)
    filenames = {L: opts.filenames[0],
                 M: opts.filenames[1],
                 R: opts.filenames[2]}
  else:
    parser.error("Invalid number of files: should be 2 or 3")

  # Get the terminal's width.
  width = (curses.tigetnum('cols') - ((nfiles-1) * len(SEPARATOR))) / nfiles

  global EMPTY_LINE
  EMPTY_LINE = opts.blank_char * 200

  render_diffs(filenames, hunks, sys.stdout, width)


def format_filename(filename, width):
  """Format a filename for printability."""
  if len(filename) > width:
    return '...{}'.format(filename[-(width-3):])
  else:
    return filename


def render_diffs(filenames, hunks, outf, width):
  """Render the diffs from the given filenames and hunks, to file object 'outf',
  and constrained by 'width' characters."""

  nfiles = len(filenames)

  # Render the filenames as a title at the top.
  render_line(outf, format_filename(filenames[L], width), COLOR_TITLE, width)
  outf.write(SEPARATOR)
  if nfiles == 3:
    render_line(outf, format_filename(filenames[M], width), COLOR_TITLE, width)
    outf.write(SEPARATOR)
  render_line(outf, format_filename(filenames[R], width), COLOR_TITLE, width)
  outf.write('\n')

  files = dict((k, FileWithNo(open(v))) for (k, v) in filenames.iteritems())
  for hunk in hunks:
    ##print '********************', hunk

    # Check sizes
    sizeL = hunk.linesL[0] - files[L].lineno
    sizeR = hunk.linesR[0] - files[R].lineno
    assert sizeL == sizeR, (str(hunk), files)
    if nfiles == 3:
      sizeM = hunk.linesM[0] - files[M].lineno
      assert sizeM == sizeL, (hunk, files)

    # Render same lines.
    while files[L].lineno < hunk.linesL[0]:
      lineL = files[L].readline()
      lineR = files[R].readline()
      if nfiles != 2:
        lineM = files[M].readline()

      if nfiles == 2:
        colL, colR = HUNK_COLORS_2[LINE_SAME]
        render_line(outf, lineL, colL, width)
        outf.write(SEPARATOR)
        render_line(outf, lineR, colR, width)
      else:
        colL, colM, colR = HUNK_COLORS_3[LINE_SAME]
        render_line(outf, lineL, colL, width)
        outf.write(SEPARATOR)
        render_line(outf, lineM, colM, width)
        outf.write(SEPARATOR)
        render_line(outf, lineR, colR, width)

      outf.write('\n')

    # Render diff hunk.
    while 1:
      didread = False
      lineL = lineR = lineM = None
      if files[L].lineno < hunk.linesL[1]:
        lineL = files[L].readline()
        didread = True

      if files[R].lineno < hunk.linesR[1]:
        lineR = files[R].readline()
        didread = True

      if nfiles == 3 and files[M].lineno < hunk.linesM[1]:
        lineM = files[M].readline()
        didread = True

      if not didread:
        break

      if nfiles == 2:
        hd = compute_horizontal_diffs({L: lineL, R: lineR})
        colL, colR = HUNK_COLORS_2[hunk.hunk_type]
        render_line(outf, lineL, colL, width, hd[L])
        outf.write(SEPARATOR)
        render_line(outf, lineR, colR, width, hd[R])
      else:
        hd = compute_horizontal_diffs({L: lineL, R: lineR, M: lineM})
        colL, colM, colR = HUNK_COLORS_3[hunk.hunk_type]
        render_line(outf, lineL, colL, width, hd[L])
        outf.write(SEPARATOR)
        render_line(outf, lineM, colM, width, hd[M])
        outf.write(SEPARATOR)
        render_line(outf, lineR, colR, width, hd[R])

      outf.write('\n')

  # Render the same region at the end of the file.
  while 1:
    lineL = files[L].readline()
    lineR = files[R].readline()
    if nfiles != 2:
      lineM = files[M].readline()
    if not lineL and not lineR and (nfiles == 2 or not lineM):
      break

    if nfiles == 2:
      colL, colR = HUNK_COLORS_2[LINE_SAME]
      render_line(outf, lineL, colL, width)
      outf.write(SEPARATOR)
      render_line(outf, lineR, colR, width)
    else:
      colL, colM, colR = HUNK_COLORS_3[LINE_SAME]
      render_line(outf, lineL, colL, width)
      outf.write(SEPARATOR)
      render_line(outf, lineM, colM, width)
      outf.write(SEPARATOR)
      render_line(outf, lineR, colR, width)

    outf.write('\n')




#-------------------------------------------------------------------------------

def find_colors():
  "One-off funciton used to compute the terminal colors corresponding to xxdiff's."
  colors = [
      ( 'COLOR_SAME                 ' , "#bebebe", "#000000" ),
      ( 'COLOR_SAME_BLANK           ' , "#b3b3b3", "#000000" ),
      ( 'COLOR_DIFF_ONE             ' , "#eee8aa", "#000000" ),
      ( 'COLOR_DIFF_ONE_SUP         ' , "#cdc9a5", "#000000" ),
      ( 'COLOR_DIFF_TWO             ' , "#b2dfee", "#000000" ),
      ( 'COLOR_DIFF_TWO_SUP         ' , "#9ac0cd", "#000000" ),
      ( 'COLOR_DELETE               ' , "#b2dfee", "#000000" ),
      ( 'COLOR_DELETE_BLANK         ' , "#a3a3a3", "#000000" ),
      ( 'COLOR_INSERT               ' , "#b4eeb4", "#000000" ),
      ( 'COLOR_INSERT_BLANK         ' , "#a3a3a3", "#000000" ),
      ( 'COLOR_SELECTED             ' , "#dda0dd", "#000000" ),
      ( 'COLOR_SELECTED_SUP         ' , "#d8bfd8", "#000000" ),
      ( 'COLOR_IGNORE_DISPLAY       ' , "#d9d9d9", "#000000" ),
      ( 'COLOR_IGNORE_DISPLAY_SUP   ' , "#cccccc", "#000000" ),
      ( 'COLOR_IGNORE_DISPLAY_ONLY  ' , "#cccccc", "#000000" ),
      ( 'COLOR_IGNORE_DISPLAY_NONLY ' , "#cccccc", "#000000" ),
      ( 'COLOR_DELETED              ' , "#778899", "#000000" ),
      ( 'COLOR_DELETED_SUP          ' , "#708090", "#000000" ),
      ( 'COLOR_IGNORED              ' , "#b3b3b3", "#4d4d4d" ),
      ( 'COLOR_DIRECTORIES          ' , "#48d1cc", "#000000" ),
      ( 'COLOR_MERGED_UNDECIDED     ' , "#cdc9a5", "#000000" ),
      ( 'COLOR_MERGED_DECIDED_1     ' , "#999999", "#000000" ),
      ( 'COLOR_MERGED_DECIDED_1_SUP ' , "#b3b3b3", "#000000" ),
      ( 'COLOR_MERGED_DECIDED_2     ' , "#999999", "#000000" ),
      ( 'COLOR_MERGED_DECIDED_2_SUP ' , "#b3b3b3", "#000000" ),
      ( 'COLOR_MERGED_DECIDED_3     ' , "#999999", "#000000" ),
      ( 'COLOR_MERGED_DECIDED_3_SUP ' , "#b3b3b3", "#000000" ),
      ( 'COLOR_MERGED_DECIDED_NEITHER' , "#b3b3b3", "#000000" ),
      ]
  import mapcolors
  for color_name, color_bg, color_fg in colors:
    (rgb, color_id, distance) = mapcolors.find_closest_color(mapcolors.getrgb(color_bg))
    print curses.tparm(curses.tigetstr('setab'), color_id),
    (rgb, color_id, distance) = mapcolors.find_closest_color(mapcolors.getrgb(color_fg))
    print curses.tparm(curses.tigetstr('setaf'), color_id),
    print color_name
  print curses.tparm(curses.tigetstr('setab'), 0)
  print curses.tparm(curses.tigetstr('setaf'), 7)

  for color_name, color_bg, color_fg in colors:
    (rgb, color_id, distance) = mapcolors.find_closest_color(mapcolors.getrgb(color_bg))
    print color_name, color_id


if __name__ == '__main__':
  curses.setupterm()
  ##print curses.getmaxyx()
  init_colors()
  #find_colors()
  main()
